#!/usr/bin/env python3
# nargs=REMAINDER

import os
from argparse import ArgumentParser, REMAINDER
from subprocess import Popen, PIPE


INC_DEPTH = 'ctrl-s'
DEC_DEPTH = 'ctrl-a'
DOWN_TREE = 'ctrl-g'
UP_TREE   = 'ctrl-f'


def get_args():
    parser = ArgumentParser()
    parser.add_argument('start_node', metavar='START_NODE')
    parser.add_argument('-f', '--file-only', action='store_true')
    parser.add_argument('-v', '--var-depth')
    parser.add_argument('-e', '--extra', dest='find_args', nargs=REMAINDER)
    return parser.parse_args()


def resolve_link(path):
    while os.path.islink(path):
        path = os.readlink(path)
    return path


def resolve_to_dir(path):
    if os.path.islink(path):
        return resolve_dir(os.readlink(path))
    elif os.path.isdir(path):
        return path
    elif os.path.isfile(path):
        return os.path.dirname(path)
    else:
        return None


def expects_of(args):
    expects = [UP_TREE]
    if not args.file_only:
        expects.append(DOWN_TREE)
    if args.var_depth is not None:
        expects.extend((INC_DEPTH, DEC_DEPTH))
    return expects


def choose(args):

    curr = resolve_to_dir(args.start_node)
    if curr is None:
        raise Exception('could not resolve ' + args.start_node)
    depth = args.var_depth

    while True:

        fzf_cmd = [
            'fzf',
            '--nth=2..',
            '--header=' + os.path.abspath(curr),
            '--expect=' + ','.join(expects_of(args)),
            ]

        find_cmd = sum([
                ['find', curr],
                [] if args.var_depth is None else ['-maxdepth', args.var_depth],
                ['!', '-readable', '-prune', '-o'],
                [] if args.find_args is None else ['-o' '('] + args.find_args + [')'],
                ['-print'],
            ], [])

        find_proc = Popen(find_cmd, stdout=PIPE)
        fzf_proc = Popen(fzf_cmd, stdin=PIPE, stdout=PIPE)

        for bline in find_proc.stdout:
            line = bline.decode('utf8')[:-1]
            if line != curr:
                if os.path.isfile(line):
                    if os.path.islink(line):
                        prefix = u'\U000021E5'
                    else:
                        prefix = u'\U00002022'
                elif os.path.isdir(line):
                    if os.path.islink(line):
                        prefix = u'\U00002192'
                        # prefix = u'\U000021A0'
                    else:
                        prefix = u'\U000025B6'
                else:
                    prefix = '?'
                fmt = prefix + ' ' + line[len(curr) + 1:] + '\n'
                fzf_proc.stdin.write(bytes(fmt, 'UTF-8'))
                fzf_proc.stdin.flush()

        try:
            action = next(fzf_proc.stdout).decode('utf8')[:-1]
            choice = os.path.join(curr, next(fzf_proc.stdout).decode('utf8')[2:-1])
        except StopIteration:
            return None

        if action == UP_TREE:
            curr = os.path.join(curr, os.pardir)
        elif action == DOWN_TREE:
            res = resolve_link(choice) 
            if os.path.isdir(res):
                curr = res
        elif action == INC_DEPTH:
            depth += 1
        elif action == DEC_DEPTH and 1 < depth:
            depth -= 1
        else:
            if args.file_only:
                res = resolve_link(choice) 
                if os.path.isdir(res):
                    curr = res
                else:
                    return choice
            else:
                return choice


def main():
    choice = choose(get_args())
    if choice is not None:
        print(choice)


if __name__ == '__main__':
    main()
